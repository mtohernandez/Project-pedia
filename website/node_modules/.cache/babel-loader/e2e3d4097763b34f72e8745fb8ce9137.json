{"ast":null,"code":"import { colorMix, getStyleFromHsl, getStyleFromRgb } from \"./ColorUtils\";\nexport function drawLine(context, begin, end) {\n  context.beginPath();\n  context.moveTo(begin.x, begin.y);\n  context.lineTo(end.x, end.y);\n  context.closePath();\n}\nexport function drawTriangle(context, p1, p2, p3) {\n  context.beginPath();\n  context.moveTo(p1.x, p1.y);\n  context.lineTo(p2.x, p2.y);\n  context.lineTo(p3.x, p3.y);\n  context.closePath();\n}\nexport function paintBase(context, dimension, baseColor) {\n  context.save();\n  context.fillStyle = baseColor !== null && baseColor !== void 0 ? baseColor : \"rgba(0,0,0,0)\";\n  context.fillRect(0, 0, dimension.width, dimension.height);\n  context.restore();\n}\nexport function clear(context, dimension) {\n  context.clearRect(0, 0, dimension.width, dimension.height);\n}\nexport function drawConnectLine(context, width, lineStyle, begin, end) {\n  context.save();\n  drawLine(context, begin, end);\n  context.lineWidth = width;\n  context.strokeStyle = lineStyle;\n  context.stroke();\n  context.restore();\n}\nexport function gradient(context, p1, p2, opacity) {\n  const gradStop = Math.floor(p2.getRadius() / p1.getRadius()),\n        color1 = p1.getFillColor(),\n        color2 = p2.getFillColor();\n\n  if (!color1 || !color2) {\n    return;\n  }\n\n  const sourcePos = p1.getPosition(),\n        destPos = p2.getPosition(),\n        midRgb = colorMix(color1, color2, p1.getRadius(), p2.getRadius()),\n        grad = context.createLinearGradient(sourcePos.x, sourcePos.y, destPos.x, destPos.y);\n  grad.addColorStop(0, getStyleFromHsl(color1, opacity));\n  grad.addColorStop(gradStop > 1 ? 1 : gradStop, getStyleFromRgb(midRgb, opacity));\n  grad.addColorStop(1, getStyleFromHsl(color2, opacity));\n  return grad;\n}\nexport function drawGrabLine(context, width, begin, end, colorLine, opacity) {\n  context.save();\n  drawLine(context, begin, end);\n  context.strokeStyle = getStyleFromRgb(colorLine, opacity);\n  context.lineWidth = width;\n  context.stroke();\n  context.restore();\n}\nexport function drawParticle(container, context, particle, delta, colorStyles, backgroundMask, composite, radius, opacity, shadow) {\n  var _a, _b, _c, _d;\n\n  const pos = particle.getPosition(),\n        tiltOptions = particle.options.tilt,\n        rollOptions = particle.options.roll;\n  context.save();\n\n  if (tiltOptions.enable || rollOptions.enable) {\n    const roll = rollOptions.enable && particle.roll,\n          tilt = tiltOptions.enable && particle.tilt,\n          rollHorizontal = roll && (rollOptions.mode === \"horizontal\" || rollOptions.mode === \"both\"),\n          rollVertical = roll && (rollOptions.mode === \"vertical\" || rollOptions.mode === \"both\");\n    context.setTransform(rollHorizontal ? Math.cos(particle.roll.angle) : 1, tilt ? Math.cos(particle.tilt.value) * particle.tilt.cosDirection : 0, tilt ? Math.sin(particle.tilt.value) * particle.tilt.sinDirection : 0, rollVertical ? Math.sin(particle.roll.angle) : 1, pos.x, pos.y);\n  } else {\n    context.translate(pos.x, pos.y);\n  }\n\n  context.beginPath();\n  const angle = ((_b = (_a = particle.rotate) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : 0) + (particle.options.rotate.path ? particle.velocity.angle : 0);\n\n  if (angle !== 0) {\n    context.rotate(angle);\n  }\n\n  if (backgroundMask) {\n    context.globalCompositeOperation = composite;\n  }\n\n  const shadowColor = particle.shadowColor;\n\n  if (shadow.enable && shadowColor) {\n    context.shadowBlur = shadow.blur;\n    context.shadowColor = getStyleFromRgb(shadowColor);\n    context.shadowOffsetX = shadow.offset.x;\n    context.shadowOffsetY = shadow.offset.y;\n  }\n\n  if (colorStyles.fill) {\n    context.fillStyle = colorStyles.fill;\n  }\n\n  const stroke = particle.stroke;\n  context.lineWidth = (_c = particle.strokeWidth) !== null && _c !== void 0 ? _c : 0;\n\n  if (colorStyles.stroke) {\n    context.strokeStyle = colorStyles.stroke;\n  }\n\n  drawShape(container, context, particle, radius, opacity, delta);\n\n  if (((_d = stroke === null || stroke === void 0 ? void 0 : stroke.width) !== null && _d !== void 0 ? _d : 0) > 0) {\n    context.stroke();\n  }\n\n  if (particle.close) {\n    context.closePath();\n  }\n\n  if (particle.fill) {\n    context.fill();\n  }\n\n  context.restore();\n  context.save();\n\n  if (tiltOptions.enable && particle.tilt) {\n    context.setTransform(1, Math.cos(particle.tilt.value) * particle.tilt.cosDirection, Math.sin(particle.tilt.value) * particle.tilt.sinDirection, 1, pos.x, pos.y);\n  } else {\n    context.translate(pos.x, pos.y);\n  }\n\n  if (angle !== 0) {\n    context.rotate(angle);\n  }\n\n  if (backgroundMask) {\n    context.globalCompositeOperation = composite;\n  }\n\n  drawShapeAfterEffect(container, context, particle, radius, opacity, delta);\n  context.restore();\n}\nexport function drawShape(container, context, particle, radius, opacity, delta) {\n  if (!particle.shape) {\n    return;\n  }\n\n  const drawer = container.drawers.get(particle.shape);\n\n  if (!drawer) {\n    return;\n  }\n\n  drawer.draw(context, particle, radius, opacity, delta, container.retina.pixelRatio);\n}\nexport function drawShapeAfterEffect(container, context, particle, radius, opacity, delta) {\n  if (!particle.shape) {\n    return;\n  }\n\n  const drawer = container.drawers.get(particle.shape);\n\n  if (!(drawer === null || drawer === void 0 ? void 0 : drawer.afterEffect)) {\n    return;\n  }\n\n  drawer.afterEffect(context, particle, radius, opacity, delta, container.retina.pixelRatio);\n}\nexport function drawPlugin(context, plugin, delta) {\n  if (!plugin.draw) {\n    return;\n  }\n\n  context.save();\n  plugin.draw(context, delta);\n  context.restore();\n}\nexport function drawParticlePlugin(context, plugin, particle, delta) {\n  if (!plugin.drawParticle) {\n    return;\n  }\n\n  context.save();\n  plugin.drawParticle(context, particle, delta);\n  context.restore();\n}\nexport function drawEllipse(context, particle, fillColorValue, radius, opacity, width, rotation, start, end) {\n  if (width <= 0) {\n    return;\n  }\n\n  const pos = particle.getPosition();\n\n  if (fillColorValue) {\n    context.strokeStyle = getStyleFromHsl(fillColorValue, opacity);\n  }\n\n  context.lineWidth = width;\n  const rotationRadian = rotation * Math.PI / 180;\n  context.beginPath();\n  context.ellipse(pos.x, pos.y, radius / 2, radius * 2, rotationRadian, start, end);\n  context.stroke();\n}\nexport function alterHsl(color, type, value) {\n  return {\n    h: color.h,\n    s: color.s,\n    l: color.l + (type === \"darken\" ? -1 : 1) * value\n  };\n}","map":{"version":3,"sources":["C:/SkyRing/Project Helena Shine/Website/website/node_modules/tsparticles-engine/esm/Utils/CanvasUtils.js"],"names":["colorMix","getStyleFromHsl","getStyleFromRgb","drawLine","context","begin","end","beginPath","moveTo","x","y","lineTo","closePath","drawTriangle","p1","p2","p3","paintBase","dimension","baseColor","save","fillStyle","fillRect","width","height","restore","clear","clearRect","drawConnectLine","lineStyle","lineWidth","strokeStyle","stroke","gradient","opacity","gradStop","Math","floor","getRadius","color1","getFillColor","color2","sourcePos","getPosition","destPos","midRgb","grad","createLinearGradient","addColorStop","drawGrabLine","colorLine","drawParticle","container","particle","delta","colorStyles","backgroundMask","composite","radius","shadow","_a","_b","_c","_d","pos","tiltOptions","options","tilt","rollOptions","roll","enable","rollHorizontal","mode","rollVertical","setTransform","cos","angle","value","cosDirection","sin","sinDirection","translate","rotate","path","velocity","globalCompositeOperation","shadowColor","shadowBlur","blur","shadowOffsetX","offset","shadowOffsetY","fill","strokeWidth","drawShape","close","drawShapeAfterEffect","shape","drawer","drawers","get","draw","retina","pixelRatio","afterEffect","drawPlugin","plugin","drawParticlePlugin","drawEllipse","fillColorValue","rotation","start","rotationRadian","PI","ellipse","alterHsl","color","type","h","s","l"],"mappings":"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","sourcesContent":["import { colorMix, getStyleFromHsl, getStyleFromRgb } from \"./ColorUtils\";\nexport function drawLine(context, begin, end) {\n    context.beginPath();\n    context.moveTo(begin.x, begin.y);\n    context.lineTo(end.x, end.y);\n    context.closePath();\n}\nexport function drawTriangle(context, p1, p2, p3) {\n    context.beginPath();\n    context.moveTo(p1.x, p1.y);\n    context.lineTo(p2.x, p2.y);\n    context.lineTo(p3.x, p3.y);\n    context.closePath();\n}\nexport function paintBase(context, dimension, baseColor) {\n    context.save();\n    context.fillStyle = baseColor !== null && baseColor !== void 0 ? baseColor : \"rgba(0,0,0,0)\";\n    context.fillRect(0, 0, dimension.width, dimension.height);\n    context.restore();\n}\nexport function clear(context, dimension) {\n    context.clearRect(0, 0, dimension.width, dimension.height);\n}\nexport function drawConnectLine(context, width, lineStyle, begin, end) {\n    context.save();\n    drawLine(context, begin, end);\n    context.lineWidth = width;\n    context.strokeStyle = lineStyle;\n    context.stroke();\n    context.restore();\n}\nexport function gradient(context, p1, p2, opacity) {\n    const gradStop = Math.floor(p2.getRadius() / p1.getRadius()), color1 = p1.getFillColor(), color2 = p2.getFillColor();\n    if (!color1 || !color2) {\n        return;\n    }\n    const sourcePos = p1.getPosition(), destPos = p2.getPosition(), midRgb = colorMix(color1, color2, p1.getRadius(), p2.getRadius()), grad = context.createLinearGradient(sourcePos.x, sourcePos.y, destPos.x, destPos.y);\n    grad.addColorStop(0, getStyleFromHsl(color1, opacity));\n    grad.addColorStop(gradStop > 1 ? 1 : gradStop, getStyleFromRgb(midRgb, opacity));\n    grad.addColorStop(1, getStyleFromHsl(color2, opacity));\n    return grad;\n}\nexport function drawGrabLine(context, width, begin, end, colorLine, opacity) {\n    context.save();\n    drawLine(context, begin, end);\n    context.strokeStyle = getStyleFromRgb(colorLine, opacity);\n    context.lineWidth = width;\n    context.stroke();\n    context.restore();\n}\nexport function drawParticle(container, context, particle, delta, colorStyles, backgroundMask, composite, radius, opacity, shadow) {\n    var _a, _b, _c, _d;\n    const pos = particle.getPosition(), tiltOptions = particle.options.tilt, rollOptions = particle.options.roll;\n    context.save();\n    if (tiltOptions.enable || rollOptions.enable) {\n        const roll = rollOptions.enable && particle.roll, tilt = tiltOptions.enable && particle.tilt, rollHorizontal = roll && (rollOptions.mode === \"horizontal\" || rollOptions.mode === \"both\"), rollVertical = roll && (rollOptions.mode === \"vertical\" || rollOptions.mode === \"both\");\n        context.setTransform(rollHorizontal ? Math.cos(particle.roll.angle) : 1, tilt ? Math.cos(particle.tilt.value) * particle.tilt.cosDirection : 0, tilt ? Math.sin(particle.tilt.value) * particle.tilt.sinDirection : 0, rollVertical ? Math.sin(particle.roll.angle) : 1, pos.x, pos.y);\n    }\n    else {\n        context.translate(pos.x, pos.y);\n    }\n    context.beginPath();\n    const angle = ((_b = (_a = particle.rotate) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : 0) + (particle.options.rotate.path ? particle.velocity.angle : 0);\n    if (angle !== 0) {\n        context.rotate(angle);\n    }\n    if (backgroundMask) {\n        context.globalCompositeOperation = composite;\n    }\n    const shadowColor = particle.shadowColor;\n    if (shadow.enable && shadowColor) {\n        context.shadowBlur = shadow.blur;\n        context.shadowColor = getStyleFromRgb(shadowColor);\n        context.shadowOffsetX = shadow.offset.x;\n        context.shadowOffsetY = shadow.offset.y;\n    }\n    if (colorStyles.fill) {\n        context.fillStyle = colorStyles.fill;\n    }\n    const stroke = particle.stroke;\n    context.lineWidth = (_c = particle.strokeWidth) !== null && _c !== void 0 ? _c : 0;\n    if (colorStyles.stroke) {\n        context.strokeStyle = colorStyles.stroke;\n    }\n    drawShape(container, context, particle, radius, opacity, delta);\n    if (((_d = stroke === null || stroke === void 0 ? void 0 : stroke.width) !== null && _d !== void 0 ? _d : 0) > 0) {\n        context.stroke();\n    }\n    if (particle.close) {\n        context.closePath();\n    }\n    if (particle.fill) {\n        context.fill();\n    }\n    context.restore();\n    context.save();\n    if (tiltOptions.enable && particle.tilt) {\n        context.setTransform(1, Math.cos(particle.tilt.value) * particle.tilt.cosDirection, Math.sin(particle.tilt.value) * particle.tilt.sinDirection, 1, pos.x, pos.y);\n    }\n    else {\n        context.translate(pos.x, pos.y);\n    }\n    if (angle !== 0) {\n        context.rotate(angle);\n    }\n    if (backgroundMask) {\n        context.globalCompositeOperation = composite;\n    }\n    drawShapeAfterEffect(container, context, particle, radius, opacity, delta);\n    context.restore();\n}\nexport function drawShape(container, context, particle, radius, opacity, delta) {\n    if (!particle.shape) {\n        return;\n    }\n    const drawer = container.drawers.get(particle.shape);\n    if (!drawer) {\n        return;\n    }\n    drawer.draw(context, particle, radius, opacity, delta, container.retina.pixelRatio);\n}\nexport function drawShapeAfterEffect(container, context, particle, radius, opacity, delta) {\n    if (!particle.shape) {\n        return;\n    }\n    const drawer = container.drawers.get(particle.shape);\n    if (!(drawer === null || drawer === void 0 ? void 0 : drawer.afterEffect)) {\n        return;\n    }\n    drawer.afterEffect(context, particle, radius, opacity, delta, container.retina.pixelRatio);\n}\nexport function drawPlugin(context, plugin, delta) {\n    if (!plugin.draw) {\n        return;\n    }\n    context.save();\n    plugin.draw(context, delta);\n    context.restore();\n}\nexport function drawParticlePlugin(context, plugin, particle, delta) {\n    if (!plugin.drawParticle) {\n        return;\n    }\n    context.save();\n    plugin.drawParticle(context, particle, delta);\n    context.restore();\n}\nexport function drawEllipse(context, particle, fillColorValue, radius, opacity, width, rotation, start, end) {\n    if (width <= 0) {\n        return;\n    }\n    const pos = particle.getPosition();\n    if (fillColorValue) {\n        context.strokeStyle = getStyleFromHsl(fillColorValue, opacity);\n    }\n    context.lineWidth = width;\n    const rotationRadian = (rotation * Math.PI) / 180;\n    context.beginPath();\n    context.ellipse(pos.x, pos.y, radius / 2, radius * 2, rotationRadian, start, end);\n    context.stroke();\n}\nexport function alterHsl(color, type, value) {\n    return {\n        h: color.h,\n        s: color.s,\n        l: color.l + (type === \"darken\" ? -1 : 1) * value,\n    };\n}\n"]},"metadata":{},"sourceType":"module"}